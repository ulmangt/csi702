
#define MAX_RANGE 20000 // meters
#define MAX_VEL 15 // meters per second

#define DEVICE_PI acosf(-1)

// linear congruential random number generator constants
// these values are used in java.util.Random.next()
#define a 0x5DEECE66DL
#define c 0xB
#define mask_bits 48
// generate only 31 bits so that we always generate positive integers
#define result_bits 31

// bit mask the least significant m bits
const long mask = ( 1L << mask_bits ) - 1;

const int LCG_RAND_MAX = ( 1 << result_bits ) - 1;

// implementation based on examples from:
// http://en.wikipedia.org/wiki/Linear_congruential_generator
// java.util.Random.next()
__device__ int device_lcg_rand( int x )
{
  // bitwise and with mask is equivalent to mod 2^mask_bits
  long xl = (x * a + c) & mask;
  // we have generated mask_bits but only need result_bits
  // use the highest order bits because they have longer periods
  return (int) ( xl >> ( mask_bits - result_bits ) );
}

// Return a random float value evenly distributed between 0 and max
// Because cuda threads will keep track of their own seeds, this function
// and the others like it are not random. They simply take an already
// generated random value (seed) and transform it in some way.
// Seed values should be generated by repeated calls to device_lcg_rand().
__device__ float device_frand0( int seed, float max )
{
  return ( float ) seed / ( float ) RAND_MAX * max ;
}

// return a random float value evenly distributed between min and max
__device__ float device_frand( int seed, float min, float max )
{
  float diff = max - min;
  return device_frand0( seed, diff ) + min;
}

// CUDA kernel function : initialize a particle
__global__ void init_particle_val( float *d_x_pos, float *d_y_pos, float *d_x_vel, float *d_y_vel, float *d_weight, float *d_seed )
{
  int index = blockIdx.x * blockDim.x + threadIdx.x;

  int seed = d_seed[index];

  d_x_pos[index]  = device_frand( seed, -MAX_RANGE, MAX_RANGE );
  seed = device_lcg_rand( seed );
  d_y_pos[index]  = device_frand( seed, -MAX_RANGE, MAX_RANGE );
  seed = device_lcg_rand( seed );
  d_x_vel[index]  = device_frand( seed, -MAX_VEL, MAX_VEL );
  seed = device_lcg_rand( seed );
  d_y_vel[index]  = device_frand( seed, -MAX_VEL, MAX_VEL );
  seed = device_lcg_rand( seed );
  d_weight[index] = 1.0;

  d_seed[index] = seed;
}


// particles in host memory
float *h_x_pos; // meters
float *h_y_pos; // meters
float *h_x_vel; // meters/second
float *h_y_vel; // meters/second
float *h_weight;
float *h_seed; // random seed for particle

// particles in device memory
float *d_x_pos; // meters
float *d_y_pos; // meters
float *d_x_vel; // meters/second
float *d_y_vel; // meters/second
float *d_weight;
float *d_seed; // random seed for particle



extern "C" void h_init_seed( int num )
{
  int i;

  for ( i = 0 ; i < num ; i++ )
  {
    h_seed[i] = rand();
  }
}

extern "C" void copy_particles_host_to_device( int num )
{
  int size = sizeof( float ) * num;

  cudaMemcpy( h_x_pos, d_x_pos, size, cudaMemcpyHostToDevice );
  cudaMemcpy( h_y_pos, d_y_pos, size, cudaMemcpyHostToDevice );
  cudaMemcpy( h_x_vel, d_x_vel, size, cudaMemcpyHostToDevice );
  cudaMemcpy( h_y_vel, d_y_vel, size, cudaMemcpyHostToDevice );
  cudaMemcpy( h_weight, d_weight, size, cudaMemcpyHostToDevice );
  cudaMemcpy( h_seed, d_seed, size, cudaMemcpyHostToDevice );
}

extern "C" void copy_particles_device_to_host( int num )
{
  int size = sizeof( float ) * num;

  cudaMemcpy( h_x_pos, d_x_pos, size, cudaMemcpyDeviceToHost );
  cudaMemcpy( h_y_pos, d_y_pos, size, cudaMemcpyDeviceToHost );
  cudaMemcpy( h_x_vel, d_x_vel, size, cudaMemcpyDeviceToHost );
  cudaMemcpy( h_y_vel, d_y_vel, size, cudaMemcpyDeviceToHost );
  cudaMemcpy( h_weight, d_weight, size, cudaMemcpyDeviceToHost );
  cudaMemcpy( h_seed, d_seed, size, cudaMemcpyDeviceToHost );
}

// allocate memory for num particles on host
extern "C" void h_init_particle_mem( int num )
{
  int size = sizeof( float ) * num;

  h_x_pos  = ( float* ) malloc( size );
  h_y_pos  = ( float* ) malloc( size );
  h_x_vel  = ( float* ) malloc( size );
  h_y_vel  = ( float* ) malloc( size );
  h_weight = ( float* ) malloc( size );
  h_seed = ( float* ) malloc( size );
}

// allocate memory for num particles on device
extern "C" void d_init_particle_mem( int num )
{
  int size = sizeof( float ) * num;

  cudaMalloc( (void **) &d_x_pos, size );
  cudaMalloc( (void **) &d_y_pos, size );
  cudaMalloc( (void **) &d_x_vel, size );
  cudaMalloc( (void **) &d_y_vel, size );
  cudaMalloc( (void **) &d_weight, size );
  cudaMalloc( (void **) &d_seed, size );
}

// free particle memory on host
extern "C" void h_free_particle_mem( )
{
  free( h_x_pos );
  free( h_y_pos );
  free( h_x_vel );
  free( h_y_vel );
  free( h_weight );
  free( h_seed );
}

// free particle memory on device
extern "C" void d_free_particle_mem( )
{
  cudaFree( d_x_pos );
  cudaFree( d_y_pos );
  cudaFree( d_x_vel );
  cudaFree( d_y_vel );
  cudaFree( d_weight );
  cudaFree( d_seed );
}







