#include "device_filter_math.h"

// implementation based on examples from:
// http://en.wikipedia.org/wiki/Linear_congruential_generator
// java.util.Random.next()
__device__ int device_lcg_rand( int x )
{
  // bitwise and with mask is equivalent to mod 2^mask_bits
  long xl = (x * a + c) & mask;
  // we have generated mask_bits but only need result_bits
  // use the highest order bits because they have longer periods
  return (int) ( xl >> ( mask_bits - result_bits ) );
}

// Return a random float value evenly distributed between 0 and max
// Because cuda threads will keep track of their own seeds, this function
// and the others like it are not random. They simply take an already
// generated random value (seed) and transform it in some way.
// Seed values should be generated by repeated calls to device_lcg_rand().
__device__ float device_frand0( int seed, float max )
{
  return ( float ) seed / ( float ) RAND_MAX * max ;
}

// return a random float value evenly distributed between min and max
__device__ float device_frand( int seed, float min, float max )
{
  float diff = max - min;
  return device_frand0( seed, diff ) + min;
}

// return an exponentially distributed random float
__device__ float device_erand( int seed, float inv_lambda )
{
  return -log( device_frand0( seed, 1.0 ) ) * inv_lambda;
}

// return a float value chosen from the normal distribution
// algorithm from polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, 
// as described by Donald E. Knuth in The Art of Computer Programming,
// Volume 2: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P
// also the implementation used by java.util.Random.nextGaussian
__device__ float device_grand0( int seed1, int seed2 )
{
  float v1, v2, s;
  
  do
  { 
    v1 = device_frand(seed1,-1,1);
    v2 = device_frand(seed2,-1,1);
    s = v1 * v1 + v2 * v2;
  }
  while ( s >= 1 || s == 0 );
  
  float multiplier = sqrtf(-2 * logf(s)/s);
  
  return v1 * multiplier;
}

// returns a random float value from a gaussian distribution
// with the given mean and sigma
__device__ float device_grand( int seed1, int seed2, float mean, float sigma )
{
  return mean + sigma * device_grand0( seed1, seed2 );
}

// calculates the probability density function for the gaussian
// distribution with given mean and sigma
__device__ float device_gvalue( float value, float mean, float sigma )
{
  float z = ( value - mean ) / sigma ;
  return expf( -0.5 * z * z ) / ( sqrtf( 2.0 * DEVICE_PI ) * sigma );
}
