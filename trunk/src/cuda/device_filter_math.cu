
#include "device_filter_math.h"
#include "cuda_util.h"

// CUDA kernel function : initialize a particle
__global__ void init_particle_val( float max_range, float max_vel,
                                   float *d_x_pos, float *d_y_pos,
                                   float *d_x_vel, float *d_y_vel,
                                   float *d_weight, float *d_seed )
{
  int index = blockIdx.x * blockDim.x + threadIdx.x;

  int seed = d_seed[index];

  d_x_pos[index]  = device_frand( seed, -max_range, max_range );
  seed = device_lcg_rand( seed );
  d_y_pos[index]  = device_frand( seed, -max_range, max_range );
  seed = device_lcg_rand( seed );
  d_x_vel[index]  = device_frand( seed, -max_vel, max_vel );
  seed = device_lcg_rand( seed );
  d_y_vel[index]  = device_frand( seed, -max_vel, max_vel );
  seed = device_lcg_rand( seed );
  d_weight[index] = 1.0;

  d_seed[index] = seed;
}

extern "C" void init_particles( int numBlocks, int numThreadsPerBlock,
                           float max_range, float max_vel,
                           float *d_x_pos, float *d_y_pos,
                           float *d_x_vel, float *d_y_vel,
                           float *d_weight, float *d_seed )
{
  // launch kernel
  dim3 dimGrid(numBlocks);
  dim3 dimBlock(numThreadsPerBlock);
  init_particle_val<<< dimGrid, dimBlock >>>( max_range, max_vel, d_x_pos, d_y_pos, d_x_vel, d_y_vel, d_weight, d_seed );

  // block until the device has completed kernel execution
  cudaThreadSynchronize();

  // check if the init_particle_val kernel generated errors
  //checkCUDAError("init_particle_val");
}


// implementation based on examples from:
// http://en.wikipedia.org/wiki/Linear_congruential_generator
// java.util.Random.next()
__device__ int device_lcg_rand( int x )
{
  // bitwise and with mask is equivalent to mod 2^mask_bits
  long xl = (x * a + c) & mask;
  // we have generated mask_bits but only need result_bits
  // use the highest order bits because they have longer periods
  return (int) ( xl >> ( mask_bits - result_bits ) );
}

// Return a random float value evenly distributed between 0 and max
// Because cuda threads will keep track of their own seeds, this function
// and the others like it are not random. They simply take an already
// generated random value (seed) and transform it in some way.
// Seed values should be generated by repeated calls to device_lcg_rand().
__device__ float device_frand0( int seed, float max )
{
  return ( float ) seed / ( float ) RAND_MAX * max ;
}

// return a random float value evenly distributed between min and max
__device__ float device_frand( int seed, float min, float max )
{
  float diff = max - min;
  return device_frand0( seed, diff ) + min;
}

// return an exponentially distributed random float
__device__ float device_erand( int seed, float inv_lambda )
{
  return -log( device_frand0( seed, 1.0 ) ) * inv_lambda;
}

// return a float value chosen from the normal distribution
// algorithm from polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, 
// as described by Donald E. Knuth in The Art of Computer Programming,
// Volume 2: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P
// also the implementation used by java.util.Random.nextGaussian
__device__ float device_grand0( int seed1, int seed2 )
{
  float v1, v2, s;
  
  do
  { 
    v1 = device_frand(seed1,-1,1);
    v2 = device_frand(seed2,-1,1);
    s = v1 * v1 + v2 * v2;
  }
  while ( s >= 1 || s == 0 );
  
  float multiplier = sqrtf(-2 * logf(s)/s);
  
  return v1 * multiplier;
}

// returns a random float value from a gaussian distribution
// with the given mean and sigma
__device__ float device_grand( int seed1, int seed2, float mean, float sigma )
{
  return mean + sigma * device_grand0( seed1, seed2 );
}

// calculates the probability density function for the gaussian
// distribution with given mean and sigma
__device__ float device_gvalue( float value, float mean, float sigma )
{
  float z = ( value - mean ) / sigma ;
  return expf( -0.5 * z * z ) / ( sqrtf( 2.0 * DEVICE_PI ) * sigma );
}
